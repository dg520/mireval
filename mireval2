#!/usr/bin/env python

from __future__ import division
import threading
import time
import shlex, subprocess
import commands
import re
#import cgi, cgitb
import os, sys, getopt
from operator import itemgetter
#from Bio import Motif
from Bio import motifs
from Bio import SeqIO
from Bio.Alphabet import IUPAC
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet import generic_dna, generic_rna
from Bio import SeqFeature
from Bio.SeqFeature import FeatureLocation
from Bio.SeqFeature import SeqFeature
from Bio.Blast import NCBIXML


# for i in *.gff3;do echo $i;head -n 10 $i | grep -m 1 -i "homo sapiens";done > toto
# less toto | grep -B 1 -i "Homo" 

# fetch seq from blastdb
# blastdbcmd -db blastdb -dbtype nucl -entry NC_000013 -strand minus -range 50623252-50623340 -outfmt %s

# fetch socre
# /home/shared/mireval/bigWigToBedGraph score.bw -chrom=chrX -start=60540 -end=60549 score.txt

# lift rfam and mir
# /home/shared/mireval/liftOver bta.gff3 -gff /home/shared/mireval/genomes/XXX/liftover/bosTau6ToBosTau7.over.chain new.gff3 unmapped.gff3

def usage():
    print """
USAGE: ./mireval_command_line.py -i <input_file> -d <blastdb> -v <chrom_size_file> -o <output_folder_name> [-m|-r|-T|-C|-S|-M|-R|l|a|b|x|y]

Options:
-i              Input FASTA file [Compulsory]
-d              BLAST Database. [Optional]
-v              Chromosome-size file. [Compulsory when -d is used]
-o              Output folder name. [Compulsory]
-m              Turn on the function to search transcription factor binding sites within 1000bp flanking each inquiry. TIME CONSUMING! Only useful when -d is applied. [Optional]
-r              Use the reverse-complementary sequence of the input. [Optional]
-T              Transcprits table in UCSC table format (please read TUTOR). Only useful when -d is applied. [Optional]
-C              Bigwig file that contains multiple aligment scores (please read TUTOR). Only useful when -d is applied. [Optional]
-S              Bigwig file that contains multiple aligment scores for closely related species (please read TUTOR). Only useful when -d is applied. [Optional]
-M              GFF3 file annotating miRNA in miRBase format. Only useful when -d is applied. [Optional]
-R              Text file indicating the names of Rfam files for the current species (please read TUTOR). Only useful when -d is applied. [Optional]
-l              Integer indicating the average length of miRNA for the current species. Default: 89 [Optional]
-a              Float number indicating the upper thresold of phylogenetic conservertion  (please read TUTOR). Only useful when -C is applied. [Optional]
-b              Float number indicating the lower thresold of phylogenetic conservertion  (please read TUTOR). Only useful when -C is applied. [Optional]
-x              Float number indicating the upper thresold of phylogenetic shadowing (please read TUTOR). Only useful when -S is applied. [Optional]
-y              Float number indicating the lower thresold of phylogenetic shadowing (please read TUTOR). Only useful when -S is applied. [Optional]
-h              Print this help
--help

"""
    return 1

def par(argv):
    #animal=""
    input_dir=""
    output_dir=""
    blast_loc=""
    cz_loc=""
    trans_loc=""
    cons_loc=""
    shad_loc=""
    mir_loc=""
    rfam_loc=""
    motif_search_opt="no"
    reverse_search_opt="no"
    mirna_length=89
    cons_up=0.7
    cons_down=0.5
    shad_up=0.7
    shad_down=0.5
    #strand=""
    
    opts, args = getopt.getopt(argv,"i:d:v:o:mrT:C:S:M:R:l:a:b:x:y:",["ifile=","dfile=","vfile=","ofile=","Tfile=","Cfile=","Sfile=","Mfile=","Rfile=","lfile=","afile=","bfile=","xfile=","yfile="])
    #try:
    #    opts, args = getopt.getopt(argv,"i:d:v:o:mrT:C:S:M:R:l:a:b:x:y:",["ifile=","dfile=","vfile=","ofile=","Tfile=","Cfile=","Sfile=","Mfile=","Rfile=","lfile=","afile=","bfile=","xfile=","yfile="])
    #except getopt.GetoptError:
    #    print "1"
    #    usage() # -X : Promyelocyte_dominent_ir_boundary; -Y : Granulocyte_dominent_ir_boundary
    #    sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            usage()
            sys.exit()
        elif opt in ("-i", "--ifile"):
            input_dir= arg
        elif opt in ("-d", "--dfile"):
            blast_loc = arg
        elif opt in ("-v", "--vfile"):
            cz_loc = arg
        elif opt in ("-o", "--ofile"):
            output_dir= arg
        elif opt in ("-T", "--Tfile"):
            trans_loc= arg
        elif opt in ("-C", "--Cfile"):
            cons_loc= arg
        elif opt in ("-S", "--Sfile"):
            shad_loc= arg
        elif opt in ("-M", "--Mfile"):
            mir_loc= arg
        elif opt in ("-R", "--Rfile"):
            rfam_loc= arg
        elif opt == "-m":
            motif_search_opt = "yes"
        elif opt=="-r":
            reverse_search_opt = "yes"
        elif opt in ("-l", "--lfile"):
            mirna_length = int(arg)
        elif opt in ("-a", "--afile"):
            cons_up = float(arg)
        elif opt in ("-b", "--bfile"):
            cons_down = float(arg)
        elif opt in ("-x", "--xfile"):
            shad_up = float(arg)
        elif opt in ("-y", "--yfile"):
            shad_down = float(arg)
        
        else:
            usage()
            sys.exit(2)

    return (input_dir, blast_loc, cz_loc, output_dir, motif_search_opt, reverse_search_opt, trans_loc, cons_loc, shad_loc, mir_loc, rfam_loc, mirna_length, cons_up, cons_down, shad_up, shad_down)




def conserve_score(root_name,result_no,chromosome,start_cor,end_cor,dirs):
    run=root_name+"/mireval/bin/bigWigToBedGraph "+dirs+" -chrom="+chromosome+" -start="+str(start_cor)+" -end="+str(end_cor)+" "+result_no+"/score_temp.txt"
    sta,out=commands.getstatusoutput(run)
    files=open(result_no+"/score_temp.txt","r")
    plot=files.readlines()
    files.close()
    if plot==[]:
        plot=[chromosome+"\t"+str(start_cor)+"\t"+str(end_cor)+"\t"+"0\n"]
    
    #run="rm "+root_name+"/mireval/html/res/"+result_no+"/score_temp.txt"
    #sta,out=commands.getstatusoutput(run)
    return plot

def score_zf(plots):
    zf=0
    for x in plots:
        tmpf=x[:-1].split("\t")
        zf=(int(tmpf[2])-int(tmpf[1])+1)*float(tmpf[3])+zf
    return zf


def score_max(plots):
    s=[]
    for x in plots:
        tmpf=x[:-1].split("\t")
        s.append(float(tmpf[3]))
    return max(s)


def neighbour_mir(root_name,chromosome,chromosome0,start_cor,end_cor,strand,dirs):
    files=open(dirs,"r")
    mir_list1=files.readlines()
    files.close()
    mir_list="\n".join(mir_list1).split("#\n\n")[-1].split("\n\n")

    upstream=[]
    upstream1=[]
    upstream2=[]
    caught=0
    for premir in mir_list:
        #if ("miRNA_primary_transcript" in premir)==False:
        mirchr=premir.split("\t")[0]
        if mirchr[0:3]!="chr":
            mirchr="chr"+mirchr
        if mirchr[-2:]==".1":
            mirchr=mirchr[:-2]
        new_chromosome="NA"
        if "_" in chromosome:
            new_chromosome="chr"+chromosome.split("_")[1]
        mirstart=int(premir.split("\t")[3])
        mirend=int(premir.split("\t")[4])
        mirname=premir.split("\t")[-1].split("Name=")[-1].split(";")[0]
        miracc=premir.split("\t")[-1].split("ID=")[-1].split(";")[0]
        mirst=premir.split("\t")[6]
        if mirchr==chromosome or mirchr==new_chromosome:
            if max(start_cor-1000,mirstart)<min(end_cor+1000,mirend):
                if ("miRNA_primary_transcript" in premir)==False:
                    upstream1.append(mirname+"\t"+miracc+";"+chromosome0+":"+str(max(start_cor-1000,mirstart))+"-"+str(min(end_cor+1000,mirend))+":"+mirst+"\n")
                else:
                    upstream2.append(mirname+"\t"+miracc+";"+chromosome0+":"+str(max(start_cor-1000,mirstart))+"-"+str(min(end_cor+1000,mirend))+":"+mirst+"\n")

            if max(start_cor,mirstart)<min(end_cor,mirend) and mirst==strand:
                caught=1
    upstream.append(upstream1)
    upstream.append(upstream2)
    upstream.append(caught)    
    return upstream


def neighbour_nc(root_name,chromosome,chromosome0,start_cor,end_cor,strand,dirs):
    files=open(dirs,"r")
    chr_list=files.readlines()
    files.close()

    neigh_rf=[]
    caught=0
    for rf in chr_list:
        rf_chr=rf.split("\t")[0]
        new_chromosome="NA"
        if "_" in chromosome:
            new_chromosome="chr"+chromosome.split("_")[1]
        if chromosome==rf_chr or rf_chr==new_chromosome:                                                       # or ("complete" in rf_chr)
            files=open(rf.split("\t")[1][:-1],"r")
            nc_list=files.readlines()
            files.close()
            for nc in nc_list:
                if nc[:2]!="##":
                    if max(start_cor,int(nc.split("\t")[3]))<min(end_cor,int(nc.split("\t")[4])) and nc.split("\t")[6]==strand:
                        rf_acc=nc.split("\t")[8].split(";")[1].split("=")[1]
                        rf_name="nc-"+nc.split("\t")[8].split(";")[2].split("=")[1]
                        rf_st=nc.split("\t")[6]
                        neigh_rf.append(rf_name+"\t"+rf_acc+";"+chromosome0+":"+str(int(nc.split("\t")[3]))+"-"+str(int(nc.split("\t")[4]))+":"+rf_st+"\n")
                    if max(start_cor,int(nc.split("\t")[3]))<min(end_cor,int(nc.split("\t")[4])) and nc.split("\t")[6]==strand:
                        caught=1
    neigh_rf.append(caught)
    return neigh_rf
  
    

def neighbour_trans(root_name,chromosome,chromosome0,start_cor,end_cor,strand,dirs):
    files=open(dirs,"r")
    trans_list1=files.readlines()
    files.close()
    trans_list=trans_list1[1:]

    neigh_trans1=[]
    neigh_trans2=[]
    neigh_trans=[]
    for trans in trans_list:
        transchr=trans.split("\t")[2]
        if transchr[0:3]!="chr":
            transchr="chr"+transchr
        transst=trans.split("\t")[3]
        transstart=int(trans.split("\t")[4])
        transend=int(trans.split("\t")[5])
        #transname=trans.split("\t")[5][:-1]
        transacc=trans.split("\t")[12]
        if transchr==chromosome and transst==strand:
            if max(start_cor-1000,transstart)<min(end_cor+1000,transend):
                neigh_trans1.append(transacc+";"+chromosome0+":"+str(max(start_cor-1000,transstart))+"-"+str(min(end_cor+1000,transend))+":"+transst+"\n")
            if max(start_cor,transstart)<min(end_cor,transend):
                neigh_trans2.append(transacc+";"+chromosome0+":"+str(transstart)+"-"+str(transend)+":"+transst+"\n")

    neigh_trans.append(neigh_trans1)
    neigh_trans.append(neigh_trans2)
    return neigh_trans



def disect(root_name,seq_name,seq_chr,chromosome0,seq_start,seq_end,seq_st,sequence,mir_length_container):        
    my_dna = Seq(sequence, generic_dna)
    sequence1=my_dna.transcribe()
    seq_frag=[]
    if mir_length_container+10<len(str(sequence1)):
        a=0
        win=mir_length_container
        while a+win<len(sequence1)+10:   
            t=str(sequence1[a:a+win]).upper()
            if seq_st=="+":
                name=">"+seq_name+";"+chromosome0+":"+str(seq_start+a)+"-"+str(seq_start+a+win-1)+":"+seq_st+"\n"
            else:
                name=">"+seq_name+";"+chromosome0+":"+str(seq_end-a-win+1)+"-"+str(seq_end-a)+":"+seq_st+"\n"
            seq_frag.append(name)
            seq_frag.append(t+"\n")
            a+=10
    else:
        name=">"+seq_name+";"+chromosome0+":"+str(seq_start)+"-"+str(seq_end)+":"+seq_st+"\n"
        seq_frag.append(name)
        seq_frag.append(str(sequence1).upper()+"\n")

    return seq_frag

def bp(struct):
    bp_list=[]

    pos=0
    left=[]
    right=[]
    for dot in struct:
        if dot=="(":
            left.append(pos)
        if dot==")":
            right.append(pos)
        pos+=1
    
    bp_p=0
    for left_pos in left:
        bp_list.append((left[bp_p],right[bp_p]))
        bp_p+=1

    return bp_list

def dinuc(sequence,dn_list):
    pos=0
    dn_c=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    while pos<len(sequence)-1:
        dn_c[dn_list.index(sequence[pos:pos+2])]+=1
        pos+=1
    dn_pos=1
    content=""
    for dn_val in dn_c[:16]:
        content=content+" "+str(dn_pos)+":"+str(dn_val/len(sequence))
        dn_pos+=1

    return content

def gu(sequence, bps_list):
    gu_c=0
    for pairs in bps_list:
        if sequence[pairs[0]]=="G" and sequence[pairs[1]]=="U":
            gu_c+=1
        if sequence[pairs[1]]=="G" and sequence[pairs[0]]=="U":
            gu_c+=1

    return gu_c

def triplet(sequence,struct,asb_list):
    mtx=[]
    m1x=[]
    i = 0
    while i<(len(sequence)-2):
        if struct[i]==")":
            tmp1="("
        else:
            tmp1=struct[i]
        if struct[i+1]==")":
            tmp2="("
        else:
            tmp2=struct[i+1]
        if struct[i+2]==")":
            tmp3="("
        else:
            tmp3=struct[i+2]
        ele=tmp1+tmp2+tmp3
        mtx.append(ele)
        m1x.append(sequence[i+1])
        i+=1

    triplet_fea=""
    fx = 24
    #fx=21
    for feas in asb_list:
        i = 0
        val=0
        while i<len(mtx):
            if feas[1:] == mtx[i] and feas[0]==m1x[i]:
                val += 1
            i += 1
        fx += 1
        fval = val/len(sequence)
        triplet_fea=triplet_fea+" "+str(fx)+":"+str(fval)

    
    return triplet_fea
    

def bulge(struct,loop_no):
    re3=re.compile("\(\.\.*\(")
    buldge_l=re3.findall(struct)
    if buldge_l==[]:
        max_buldge_l=0
    else:
        max_buldge_l=len(max(buldge_l))-2
    
    re4=re.compile("\)\.\.*\)")
    buldge_r=re4.findall(struct)
    if buldge_r==[]:
        max_buldge_r=0
        tot_br=0
    else:
        max_buldge_r=len(max(buldge_r))-2

    if loop_no==0:
        max_buldge=len(struct)

    else:
        if loop_no==1 or loop_no==2:
            max_buldge=max_buldge_r+max_buldge_l
            #max_buldge=max(max_buldge_r,max_buldge_l)
        else:
            max_buldge=loop_no*max(max_buldge_r,max_buldge_l)


    return max_buldge



def features(sequence,struct,energy,dn_list,asb_list,group):  
    #find loops
    re1=re.compile("\(\.*\)")
    loop=re1.findall(struct)

    re2=re.compile("\.*")
    buldge=re2.findall(struct)
    # total buldges, feature 24
    tot_buldge=len("".join(buldge))
    # maximum buldge size, feature 23
    max_bulge=bulge(struct,len(loop))


    # base pair list
    bps=bp(struct)
    
    # total base pairs
    if len(loop)==0 or len(loop)==1:
        tot_bp=len(bps)
    else:
        re5=re.compile("\)\.*\(")
        inner_bp=re5.findall(struct)
        max_inner_bp=max(inner_bp)
        brak_r=0
        brak_l=0
        for brak in max_inner_bp:
            if brak=="(":
                brak_l+=1
            if brak==")":
                brak_r+=1
        tot_bp=max(brak_r,brak_l)
    # number of loops, feature 22 and max loop size, feature 17 and dp/n_loop, feature 20
    if loop != []:
        loop_size=0
        n_loop=len(loop)
        if n_loop==1 or n_loop==2:
            n_loop_res=1
        else:
            n_loop_res=0
        max_loop=len(max(loop))-2
        fea20=tot_bp/len(sequence)/n_loop
    else:
        n_loop=0
        n_loop_res=0
        max_loop=0
        fea20=0

    
    
    # avg_bp_stem, feature 18
    avg_bp_stem=tot_bp/len(sequence)
    # MFEI4, feature 19 and GU property, feature 21
    if tot_bp !=0:
        mfei4=float(energy)/tot_bp
        fea21=gu(sequence, bps)/tot_bp
    else:
        mfei4=0
        fea21=0

    # write all features
    f_content=group+dinuc(sequence,dn_list)+" 17:"+str(max_loop)+" 18:"+str(avg_bp_stem)+" 19:"+str(mfei4)+" 20:"+str(fea20)+" 21:"+str(fea21)+" 22:"+str(n_loop_res)+" 23:"+str(max_bulge)+" 24:"+str(tot_buldge)+triplet(sequence,struct,asb_list)+" 57:"+energy+"\n"
    
    
    return f_content
    


def polii(root_name,seq_name,chromosome,chromosome0,start_cor,end_cor,strand,sequence, trans_list,dirs):
    seq_polii=[]
    if trans_list==[]:
        seq_temp=Seq(sequence,generic_dna)
        fast_name=seq_name+"."+str(start_cor)+"."+str(end_cor)+"."+strand+"."+"non_trans"
        fast=SeqRecord(seq_temp,fast_name,'','')
        seq_polii.append(fast)
    
    # neigh_trans.append(transacc+";"+chromosome0+":"+str(max(start_cor-1000,transstart))+"-"+str(min(end_cor+1000,transend))+":"+transst+"\n")
    else:
        for trp in trans_list:
            #if ("mir" in trp.lower())==False or (("mir" in trp.lower()) and len(trans_list)==1):
            trp_temp=trp.split(";")[1].split(":")
            trp_chr=trp_temp[0]
                
            if strand=="-":
                trp_st="2"
                trp_start=int(trp_temp[1].split("-")[1])
                prom_start=trp_start-500
                prom_end=trp_start+1000
                
            else:
                trp_st="1"
                trp_start=int(trp_temp[1].split("-")[0])
                prom_start=trp_start-1000
                prom_end=trp_start+500


            cmd1="fastacmd -d "+dirs+" -p F -s "+chromosome0+" -S "+trp_st+" -L "+str(min(prom_start,prom_end))+","+str(max(prom_start,prom_end))
            sta1,out1=commands.getstatusoutput(cmd1)
            out1=out1.split("\n")[1]
            seq_temp=Seq(out1,generic_dna)
            fast_name=seq_name+"."+str(min(prom_start,prom_end))+"."+str(max(prom_start,prom_end))+"."+strand+"."+"trans"
            fast=SeqRecord(seq_temp,fast_name,'','')
            seq_polii.append(fast)

    return seq_polii

    


def sort_list(list1):
    tmp_list=[]
    for el in list1:
        t=el.split(";")
        new_el=(t[0]+";"+t[1].split(":")[0]+":",int(t[1].split(":")[1].split("-")[0]),"-"+t[1].split(":")[1].split("-")[1]+":"+t[1].split(":")[2])
        tmp_list.append(new_el)
        
    list1_sorted=sorted(tmp_list,key=itemgetter(1))
    
    final_list=[]
    for el in list1_sorted:
        t=el[0]+str(el[1])+el[2]
        final_list.append(t)

    return final_list


def disjoint(l,res=[]):
    sl = []
    n = 1
    while n < len(l):
        p,q = l[n-1:n+1]
        if int(p.split(";")[1].split(":")[1].split("-")[1]) >= int(q.split(";")[1].split(":")[1].split("-")[0]):
           l.remove(q)
           sl.append(q)
        else:
            n+=1
    res.append(l)
    if sl: 
        disjoint(sl,res)
    return res


def cir_hist(root_name, job_id, inq_id, threshold):
    plot_content=""
    tracer_here=0
    for x in ["histo1.txt","histo2.txt"]:
        if tracer_here==0:
            my_thred=threshold[0:2]
        if tracer_here==1:
            my_thred=threshold[2:]
        histhead="<plot>\ntype=histogram\n"
        histfile="file = "+job_id+"/"+inq_id+"/"+x+"\n"
        if x=="histo1.txt":
            ori=""
            r0="r0=0.94r\n"
            r1="r1=0.99r\n"
            #url="url = http://en.wikipedia.org/wiki/Sequence_alignment\n"
        else:
            ori="orientation = in\n"
            r0="r0=0.8r\n"
            r1="r1=0.85r\n"
            #url="url = http://en.wikipedia.org/wiki/Phylogenetic_footprinting\n"

        histtail1="max=1\nmin=0\nstroke_type=outline\nextend_bin=no\n"
        histtail2="</plot>\n"
        if my_thred[0] !=0:
            background="<backgrounds>\n<background>\ny1="+str(my_thred[0])+"\ny0=0\ncolor=lblue\n</background>\n<background>\ny0="+str(my_thred[0])+"\ny1="+str(my_thred[1])+"\ncolor=vdyellow\n</background>\n<background>\ny0="+str(my_thred[1])+"\ncolor=lred\n</background>\n</backgrounds>\n"
            #rules1="color=vdblue\n"
            rules1="<rules>\n<rule>\ncondition = var(value) eq 0\nshow= no\n</rule>\n"
            #rules2=""
            rules2="<rule>\ncondition=var(value)>0 && var(value)<"+str(my_thred[0])+"\nfill_color=vdblue\n</rule>\n"
            rules3="<rule>\ncondition=var(value)>="+str(my_thred[0])+" && var(value)<"+str(my_thred[1])+"\nfill_color=vvdyellow\n</rule>\n"
            rules4="<rule>\ncondition=var(value)>="+str(my_thred[1])+" && var(value)<=1\nfill_color=vdred\n</rule>\n</rules>\n"
            #rules5="<rule>\ncondition=var(value)>="+str(my_thred[2])+"\nfill_color=vdred\n</rule>\n"
            plot_content=plot_content+histhead+histfile+ori+r1+r0+histtail1+background+rules1+rules2+rules3+rules4+histtail2
        else:
            plot_content=plot_content+histhead+histfile+ori+r1+r0+histtail1+histtail2
        tracer_here+=1

    return plot_content


def cir_text_hist(root_name, job_id, inq_id):
    plot_content=""
    plot_content1=""
    plot_content2=""
    texthead="<plot>\ntype=text\ncolor=black\n"
    textfile="file = "+job_id+"/"+inq_id+"/"+"hist_label1.txt\n"
    #textfile="file = tfb_name.txt\n"
    r0="r0= 0.94r-20p\n"
    r1="r1= 0.94r+180p\n"
    #textlink="show_links=yes\nlink_dims=4p,4p,8p,4p,4p\nlink_thickness=2p\nlink_color=black\n"
    textlabel="label_size=10p\nlabel_parallel=yes\nlabel_font=bold\npadding=0p\nrpadding=0p\n"
    #textlabel="label_size=14p\nlabel_parallel=yes\nlabel_font=condensed\n"
    #plot_content=plot_content+texthead+textfile+r0+r1+textlink+textlabel+"</plot>\n"
    plot_content1=plot_content1+texthead+textfile+r0+r1+textlabel+"</plot>\n"
    
    texthead="<plot>\ntype=text\ncolor=black\n"
    textfile="file = "+job_id+"/"+inq_id+"/"+"hist_label2.txt\n"
    r0="r0= 0.85r+0p\n"
    r1="r1= 0.85r+200p\n"
    textlabel="label_size=10p\nlabel_parallel=yes\nlabel_font=bold\npadding=0p\nrpadding=0p\n"
    plot_content2=plot_content2+texthead+textfile+r0+r1+textlabel+"</plot>\n"
    
    plot_content=plot_content1+plot_content2

    return plot_content


def cir_heatmap(root_name, job_id, inq_id):
    para=0
    plot_content=""
    col_list=["vvdpurple","green","purple","vdred","blue","orange"]
    for x in ["ref.txt","tfb.txt","transcript.txt","pred.txt","mir.txt","nc.txt"]:
        open_name=job_id+"/"+inq_id+"/"+x
        if os.path.exists(open_name)==True:
            heatfile="file = "+open_name+"\n"
            color="color = "+col_list[para]+"\n"
            url="url = "+x+"?chr=[chr]&start=[start]&end=[end]&id=[id]\n"
            if x != "tfb.txt" and x != "ref.txt":
                heathead="<plot>\ntype=tile\n"
                r0="r0= "+str(0.745-0.1*para)+"r\n"    #0.745
                r1="r1= "+str(0.785-0.1*para)+"r\n"    #0.825
                thickness="orientation = center\nlayers_overflow=collapse\n"
                if x =="transcript.txt":
                    #layer_no=str(layer(root_name, job_id, inq_id,x))
                    #layer_thickness=str(int(15/layer(root_name, job_id, inq_id,x)))
                    thickness=thickness+"layers=3\nthickness=4\nlayers_overflow_color=purple\n"
                elif x == "pred.txt":
                    thickness=thickness+"layers=3\nthickness=4\nlayers_overflow_color=vdred\n"
                elif x =="mir.txt" or x == "nc.txt":
                    thickness=thickness+"layers=2\nthickness=5\n"
            elif x=="ref.txt":
                heathead="<plot>\ntype=heatmap\n"
                r0="r0= "+str(0.765-0.1*para)+"r\n"
                r1="r1= "+str(0.775-0.1*para)+"r\n"
                thickness=""
            elif x == "tfb.txt": 
                heathead="<plot>\ntype=heatmap\n"
                r0="r0= "+str(0.765-0.1*para)+"r\n"
                r1="r1= "+str(0.785-0.1*para)+"r\n"
                thickness=""
                
            plot_content=plot_content+heathead+heatfile+color+r0+r1+thickness+url+"</plot>\n"
        para+=1

    return plot_content

def cir_text(root_name, job_id, inq_id):
    para=0
    plot_content=""
    col_list=["vvdpurple","green","purple","vdred","blue","orange"]
    for x in ["ref_label.txt","tfb_label.txt","transcript_label.txt","pred_label.txt","mir_label.txt","nc_label.txt"]:
        open_name=job_id+"/"+inq_id+"/"+x
        if os.path.exists(open_name)==True:
            texthead="<plot>\ntype=text\ncolor ="+col_list[para]+"\n"
            textfile="file = "+open_name+"\n"
            if "tfb" in x:
                r0="r0= "+str(0.765-0.1*para)+"r-25p\n"
                r1="r1= "+str(0.765-0.1*para)+"r+175p\n"
            else:
                r0="r0= "+str(0.745-0.1*para)+"r-25p\n"
                r1="r1= "+str(0.745-0.1*para)+"r+175p\n"
            textlabel="label_size=12p\nlabel_parallel=yes\nlabel_font=bold\npadding=0p\nrpadding=0.0r\n"
            #url="url = www.google.com\n"
            plot_content=plot_content+texthead+textfile+r0+r1+textlabel+"</plot>\n"
            #texthead="<>"
            para+=1
    

    return plot_content



def cir(root_name, job_id, inq_id, chr_which, threshold):
    # which chromosomes to display
    chr_show=""
    chr_totn=0
    for chr_id in chr_which:
        chr_show=chr_show+chr_id+";"
        chr_totn+=1
    chromosomes       = "chromosomes = "+   chr_show[:-1]   +"\n"

    rotate_rule=""
    if chr_totn==2:
        rotate_rule="angle_offset  = 0 \n"
    else:
        rotate_rule="angle_offset  = -90 \n"

    cir_content=""
    cir_head1="<colors>\n<<include "+root_name+"/mireval/bin/circos-0.64/etc/colors.conf>>\n<<include "+root_name+"/mireval/bin/circos-0.64/etc/brewer.conf>>\n</colors>\n"
    cir_head2="<fonts>\n<<include "+root_name+"/mireval/bin/circos-0.64/etc/fonts.conf>>\n</fonts>\n"
    cir_head3="<<include "+root_name+"/mireval/ref/conf/ideogram.conf>>\n<<include "+root_name+"/mireval/ref/conf/ticks.conf>>\n"
    cir_head4="<image>\n<<include "+root_name+"/mireval/bin/circos-0.64/etc/image.conf>>\n"+rotate_rule+"image_map_use=yes\nimage_map_name=circosmap\nimage_map_strict=removeparam\n</image>\n"
    cir_head=cir_head1+cir_head2+cir_head3+cir_head4
    karyotype   = "karyotype = "+job_id+"/"+inq_id+"/karyo.txt\n"

    chromosomes_units = "chromosomes_units = 1\n"
    chromosomes_display_default = "chromosomes_display_default =  no\n"
   
    cir_content=cir_content+cir_head+karyotype+chromosomes_units+chromosomes_display_default+chromosomes+"<plots>\n"
    cir_content=cir_content+cir_hist(root_name, job_id, inq_id, threshold)
    cir_content=cir_content+cir_heatmap(root_name, job_id, inq_id)
    cir_content=cir_content+cir_text(root_name, job_id, inq_id)
    cir_content=cir_content+cir_text_hist(root_name, job_id, inq_id)
    cir_content=cir_content+"</plots>\n<<include "+root_name+"/mireval/bin/circos-0.64/etc/housekeeping.conf>>\n"


    f=open(job_id+"/"+inq_id+"/circos.conf","w")
    f.writelines(cir_content)
    f.close()
    
    return 1


#<Main>


#f=open("PATH","r")
#root=f.readlines()[0][:-1]
#f.close()
cwd = os.getcwd()
root="/".join(cwd.split("/")[:-1])
#main_page="http://mimirna.centenary.org.au/mireval"
seq_file_path, sp, cz_dir, res_no, motif_search, reverse_search, trans_dir, cons_dir, shad_dir, mir_dir, rfam_dir, mir_length, cons1, cons2, shad1, shad2=par(sys.argv[1:])


if seq_file_path=="" or res_no=="":
    usage()
    if seq_file_path=="":
        print "Error: Need an input FASTA file."
    if res_no=="":
        print "Error: Need a folder name to save your results."
    


elif sp!="":
    if cz_dir=="":
        print "Error: Need a chromosome-size file."
        sys.exit(2)
    
    #if "/" in res_no:
    #    print "Error: output file name can only be a FOLDER NAME. No path allowed."
    #    sys.exit(2)

    cmd="mkdir "+res_no
    sta,out=commands.getstatusoutput(cmd)
    
    seq_file=seq_file_path.split("/")[-1]
    
    blast_true=1
    seq_check=[]

    f=open(seq_file_path,"rU")
    for check_record in SeqIO.parse(f,"fasta"):
        seq_check.append(check_record)
    f.close()

    if seq_check==[]:
        blast_true=0
        #cmd="rm "+seq_file_path
        #sta,out=commands.getstatusoutput(cmd)
    else:
        if reverse_search=="no":
            cmd="cp "+seq_file_path+" "+res_no+"/"
            sta,out=commands.getstatusoutput(cmd)
            #cmd="rm "+seq_file_path
            #sta,out=commands.getstatusoutput(cmd)
        else:
            d=[]
            for x in seq_check:
                up_seq=(x.seq).reverse_complement()
                up_id=(x.id)+"_complement"
                up_name=(x.name)+"_complement"
                up_des=(x.description)+"_complement"
                d.append(SeqRecord(up_seq,up_id,'',''))
            f=open(res_no+"/"+seq_file,"w")
            SeqIO.write(d, f, "fasta")
            f.close()
            #cmd="rm "+seq_file_path
            #sta,out=commands.getstatusoutput(cmd)
            
        
    
    #####################
    #miRBase            #
    #####################
    # GRCh37/hg19
    # GRCm38/mm10
    # canFam2; not up-to-date, miBase 19
    # BDGP_5.0/dm3
    # Zv9/danRer7
    # galGal4/ICGSC Gallus_gallus-4.0
    # xenTro3/JGI_4.2
    # rn4/RGSC_3.4; not up-to-date
    # CSAC_2.1.4/panTro4
    # rheMac2/MMUL_1.0; not up-to-date
    # MonDom5
    # FUGU5/fr3
    # gorGor3.1/gorGor3
    # WUGSC 7.0/petMar2
    # oryLat2/MEDAKA1
    # ornAna1/WUSTL_5.0.1
    # SGSC_Sscrofa10.2/susScr3
    # OARv3.1
    # equCab2
    # Devil_ref v7.0/sarHar1
    ##############################
    # miRBase 20 blast old genome#
    ##############################
    # Btau_4.6.1/bosTau7
    # cb3
    # WS220/ce10
    ######################## 
    # non-miRBase with cons#
    ########################
    # ponAbe2/WUSTL_2.0.2
    # GeoFor_1.0/geoFor1
    # gasAcu1/BI_1.0
    # sacCer3/Apr2011
    # braFlo1/JGI_1.0
    ###########################
    # non-miRBase without cons#
    ###########################
    # Felis_catus_6.2/felCat5
    # Broad/oryCun2
    # TWGS_Meug_1.1/macEug2

    method_avbl=[0,0,0,0,0.0,0.0,0.0,0.0]
    if cons_dir!="":
        method_avbl[0]=1
        method_avbl[4]=min(cons1,cons2)
        method_avbl[5]=max(cons1,cons2)
    if shad_dir!="":
        method_avbl[1]=1
        method_avbl[6]=min(shad1,shad2)
        method_avbl[7]=max(shad1,shad2)
    if mir_dir!="":
        method_avbl[2]=1
    if rfam_dir!="":
        method_avbl[3]=1
    
    
    # create blastdb
    # formatdb -p F -i blastdb.fa -n blastdb -o T
    
    # fetch chromosome sizes
    # /home/shared/mireval/fetchChromSizes mm10 > chrom.sizes
    
    # wig to bigWIG; not in program
    # zcat *.gz | gzip -c > score.wigFix.gz
    # cd..
    # /home/shared/mireval/wigToBigWig cons/score.wigFix.gz chrom.sizes cons/score.bw


    if blast_true==0:
        print "BLAST Error: make sure your input file is in FASTA format and your sequences DO NOT contain any other letters A,T,C,G,U,N."

    else:
        # try a BLAST against a small sample genome to check whether file is in right format or not
        cmd="blastall -p blastn -d "+root+"/mireval/ref/blast_control/primir -i "+res_no+"/"+seq_file+" -m 7 -o "+res_no+"/"+"temp.txt"
        #print cmd
        sta,out=commands.getstatusoutput(cmd)
    
        if out!="":
            blast_true=0
            print "BLAST Error: make sure your input file is in FASTA format and your sequences DO NOT contain any other letters A,T,C,G,U,N."
    
    if blast_true==1:
        hit_thres=0.95
        cmd="blastall -p blastn -d "+sp+" -i "+res_no+"/"+seq_file+" -K 4 -m 7 -o "+res_no+"/"+"temp.txt"
        sta,out=commands.getstatusoutput(cmd)
        blast_records = NCBIXML.parse(open(res_no+"/temp.txt"))
        
        dblast={}
        dfrag=[]
        dpolii=[]
        id_no=0
        base_no=1
        for blast_record in blast_records:
            blast_no=0
            name=str(blast_record.query)
    
            #base_id="inq"+str(base_no)
            base_id=base_no
            dblast[(name,base_id)]=[]
        
            hit_len=blast_record.query_letters
        
        
            chrom_file=open(cz_dir,"r")
            chrom_size=chrom_file.readlines()
            chrom_file.close()
        
            
            dict0={"inq":"", "intra_id":"", "no":0, "chr":"", "chr0":"", "start":0, "end":0, "start_outer":0, "end_outer":0, "strand":"" ,"alig":[],"plot1":[], "plot2":[], "tfb":[], "tfb_tot":[], "nearby":[], "nearby_pre":[],"frag":[], "pred":[], "trans":[],"trans_html":[],"nc":[],"disj":[],"rfam_hit":0,"mir_hit":0}
            if blast_record.alignments==[]:
                dblast[(name,base_id)].append(dict0)
            hn=0
            for alignment in blast_record.alignments:
                dict={"inq":"", "intra_id":"", "no":0, "chr":"", "chr0":"", "start":0, "end":0, "start_outer":0, "end_outer":0, "strand":"" ,"alig":[],"plot1":[], "plot2":[], "tfb":[], "tfb_tot":[], "nearby":[], "nearby_pre":[],"frag":[], "pred":[], "trans":[],"trans_html":[],"nc":[],"disj":[],"rfam_hit":0,"mir_hit":0}
                hsp=alignment.hsps[0]
                if hsp.identities<hit_len*hit_thres:
                    if hn==0:
                        dblast[(name,base_id)].append(dict)
                    break
                if hsp.identities>=hit_len*hit_thres:
                    hn=1
                    blast_no+=1
                    id_no+=1
                    dict["intra_id"]="id_"+str(id_no)
                    dict["no"]=blast_no
                    blast_name=name+"_"+str(blast_no)
                    query_start=int(hsp.query_start)
                    query_end=int(hsp.query_end)
                    entry=str(alignment.accession)
                    start=min(int(hsp.sbjct_start),int(hsp.sbjct_end))
                    end=max(int(hsp.sbjct_start),int(hsp.sbjct_end))
                    dict["start"]=start
                    dict["end"]=end
                    if hsp.frame==(1,1):
                        st="+"
                        st_name="1"
                    else:
                        st="-"
                        st_name="2"
                    dict["strand"]=st
                    if "chromosome " in alignment.title:
                        chr="chr"+str((alignment.title).split("chromosome ")[-1].split(",")[0]).split(" No definition line")[0][4:]
                    else:
                        chr=str((alignment.title).split("chromosome ")[-1].split(",")[0]).split(" No definition line")[0][4:]
                    dict["chr0"]=chr
                    if chr[0:3]!="chr":
                        chr1="chr"+chr
                    else:
                        chr1=chr
                    dict["chr"]=chr1
                    seq=str(hsp.sbjct).upper()
                    
                    #print chr
                    for x in chrom_size:
                        if chr==x.split("\t")[0] or chr1==x.split("\t")[0]:
                            chrom_end=int(x.split("\t")[1][:-1])
                            break
                    end_o=min(end+1000, chrom_end)
                    start_o=max(start-1000,1)
                    dict["start_outer"]=start_o
                    dict["end_outer"]=end_o
        
                    cmd="fastacmd -d "+sp+" -p F -s "+entry+" -S "+st_name+" -L "+str(start_o)+","+str(end_o)
                    sta,out=commands.getstatusoutput(cmd)
                    out=out.split("\n")[1]
                    seq_around=out
                    dict["alig"].append("Query "+str(query_start)+"-"+str(query_end)+"\n"+chr+":"+str(start)+"-"+str(end)+":"+st+"\n"+"Strand=Plus/"+st_name+"\n"+str(hsp.query)+"\n"+str(hsp.match)+"\n"+str(hsp.sbjct)+"\n")
                    if method_avbl[0]==1:          
                        dict["plot1"]=conserve_score(root,res_no,chr,start-1000,end+1000,cons_dir)                                       # conservation res
                    if method_avbl[1]==1:  
                        dict["plot2"]=conserve_score(root,res_no,chr,start-1000,end+1000,shad_dir)                                     # shadow res
                    if method_avbl[2]==1:
                        xtemp=neighbour_mir(root,chr1,chr,start,end,st,mir_dir)
                        dict["nearby"]=xtemp[0]
                        dict["nearby_pre"]=xtemp[1]
                        dict["mir_hit"]=xtemp[-1]
                    if method_avbl[3]==1:
                        xtemp=neighbour_nc(root,chr1,chr,start,end,st,rfam_dir)
                        dict["nc"]=xtemp[:-1]
                        dict["rfam_hit"]=xtemp[-1]
                    
                    ytemp=neighbour_trans(root,chr1,chr,start,end,st,trans_dir)
                    dict["trans"]=ytemp[0]
                    dict["trans_html"]=ytemp[1]
                    
                    dblast[(name,base_id)].append(dict)
                    dfrag=dfrag+disect(root,"id_"+str(id_no),chr1,chr,start,end,st,seq,mir_length)
                    dpolii=dpolii+polii(root,"id_"+str(id_no),chr1,chr,start_o,end_o,st,seq_around,ytemp[1],sp)
            
            base_no+=1
    
    
        # Find + prediction by svm
    
        dn=["AA","AU","AC","AG","UA","UU","UC","UG","CA","CU","CC","CG","GA","GU","GC","GG","--","-A","-U","-G","-C","A-","U-","G-","C-","NA","NN","NG","NC","NU","N-","-N","UN","GN","CN","AN"]
        asb=["(((",".((","(.(","((.","..(",".(.","(..","..."]
        nucl=['A','U','C','G']
        fea=[]
        for a in nucl:
            for b in asb:
                fea.append(a+b)
    
        f=open(res_no+"/testseq.txt","w")
        f.writelines(dfrag)
        f.close()
    
        cmd="less "+res_no+"/testseq.txt|/usr/local/bin/RNAfold --noPS > "+res_no+"/testfold.txt"
        sta,out=commands.getstatusoutput(cmd)
        
    
        f = open(res_no+"/testfold.txt","r")
        data=f.readlines()
        f.close()
    
        f = open(res_no+"/test_features.txt",'w')
        n=0
        while n<len(data):
            seq4svm =data[n+1][:-1].upper()
            fold=data[n+2].split(" ")[0]
            mfe=data[n+2].split(" ")[-1].split(")")[0].split("(")[-1]
            head_mark="0"
            temp_svm=features(seq4svm,fold,mfe,dn,fea,head_mark)
            f.write(temp_svm)
            n+=3
        f.close()
    
        cmd=root+"/mireval/bin/svm_light/bin/svm_classify "+res_no+"/test_features.txt "+root+"/mireval/ref/svm/model.txt "+res_no+"/res_svm.txt"
        sta,out=commands.getstatusoutput(cmd)
        f=open(res_no+"/res_svm.txt","r")
        svm_res=f.readlines()
        f.close()
    
        
        
        i=0
        pred_no=1
        while i< len(data):
            if float(svm_res[int(i/3)][:-1])>0:
                for y in dblast:
                    for z in dblast[y]:
                        if z["intra_id"]==data[i].split(";")[0][1:]:
                            pred_name="pred"+str(pred_no)+";"+data[i].split(";")[1][:-1]
                            pred_no+=1
                            z["pred"].append(pred_name+"\n")
                            z["frag"].append(pred_name+"\n")
                            z["frag"].append(data[i+1])
                            z["frag"].append(data[i+2])
                            break
        
            i+=3
        
        
        # TFB Finder
        if res_no[:-1]=="/":
            res_no1=res_no[:-1]
        else:
            res_no1=res_no
        res_no1=res_no1.split("/")[-1]

        if motif_search =="yes":
            f=open(res_no+"/res_4fimo_"+res_no1+".txt","w")
            SeqIO.write(dpolii, f, "fasta")
            f.close()
        
            cmd=root+"/mireval/bin/meme/bin/fimo --thresh 1e-5 --oc "+res_no+"/fimo_out/ "+root+"/mireval/ref/jaspar.meme "+res_no+"/res_4fimo_"+res_no1+".txt" 
        #cmd=root+"/mireval/bin/meme/bin/fimo --oc "+root+"/mireval/html/res/"+res_no+"/fimo_out/ "+root+"/mireval/ref/jaspar.meme "+root+"/mireval/html/res/"+res_no+"/res_4fimo_"+res_no+".txt"
            #print cmd
            sta,out=commands.getstatusoutput(cmd)
        
        
            f=open(res_no+"/fimo_out/fimo.txt","r")
            d=f.readlines()
            f.close()
        

            for x in d[1:]:
                for y in dblast:
                    for z in dblast[y]:
                        if z["intra_id"] == x.split("\t")[1].split(".")[0]:
                            pro_name=x.split("\t")[0]
                            tot_start=int(x.split("\t")[1].split(".")[1])
                            tot_end=int(x.split("\t")[1].split(".")[2])
                            tot_st=x.split("\t")[1].split(".")[3]
                            pro_start=int(x.split("\t")[2])
                            pro_end=int(x.split("\t")[3])
                            pro_st=x.split("\t")[4]
                            if tot_st=="+":
                                pro_num1=tot_start+pro_start-1
                                pro_num2=tot_start+pro_end-1
                                pro_start=min(pro_num1,pro_num2)
                                pro_end=max(pro_num1,pro_num2)
                                if "non_trans" in x.split("\t")[1]:
                                    z["tfb"].append("tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n")
                                    z["tfb_tot"].append("tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n")
                                else:
                                    pro_content="tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n"
                                    if z["start_outer"]<=pro_start and z["end_outer"]>=pro_end:   
                                        if (pro_content in z["tfb"])==False:
                                            z["tfb"].append(pro_content)
                                        if (pro_content in z["tfb_tot"])==False:
                                            z["tfb_tot"].append(pro_content)
                                    else:
                                        if (pro_content in z["tfb_tot"])==False:
                                            z["tfb_tot"].append(pro_content)
                            else:
                                pro_num1=tot_end-pro_start+1
                                pro_num2=tot_end-pro_end+1
                                pro_start=min(pro_num1,pro_num2)
                                pro_end=max(pro_num1,pro_num2)
                                if "non_trans" in x.split("\t")[1]:
                                    z["tfb"].append("tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n")
                                    z["tfb_tot"].append("tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n")
                                else:
                                    pro_content="tfb-"+pro_name+";"+z["chr"]+":"+str(pro_start)+"-"+str(pro_end)+":"+z["strand"]+"\n"
                                    if z["start_outer"]<=pro_start and z["end_outer"]>=pro_end:
                                        if (pro_content in z["tfb"])==False:
                                            z["tfb"].append(pro_content)
                                        if (pro_content in z["tfb_tot"])==False:
                                            z["tfb_tot"].append(pro_content)
                                    else:
                                        if (pro_content in z["tfb_tot"])==False:
                                            z["tfb_tot"].append(pro_content)
                            break
        
        
        
        # create circos reference files, html file and text result file
        
        sorted_keys=sorted(dblast.keys(), key=itemgetter(1, 0))
     
        summary=open(res_no+"/index.html","w")
        #summary.write("<html><head></head><body><table border=1 align=\"center\"><tr valign=\"middle\"><h2 align=\"center\">Inquiry ID: "+res_no+"</h2>\n")
        summary.write("<!DOCTYPE html>\n")
        summary.write("<html><head><meta http-equiv=Content-Type content='text/html;charset=utf-8'><link rel=\"shortcut icon\" ><title>Result Summary</title></head><h2 align=\"center\">Inquiry ID: "+res_no+"</h2>\n")
        summary.write("<b>Which sequence should I look at first?</b><br /><br />\n")
        #<td width=80 bgcolor=\"#F6CECE\"></td>
        #DF0101
        summary.write("<table border=\"0\">\n")
        summary.write("<tr height=20><th width=80 align=\"left\"></th><td width=275 bgcolor=\"#B40404\"></td><td width=275 bgcolor=\"#FA5858\"></td><td width=275 bgcolor=\"#F5A9A9\"></td><td width=275></td></tr>\n")
        summary.write("<tr><th align=\"left\">Pred</th><td align=\"center\">found hairpins</td>  <td align=\"center\"></td> <td align=\"center\"></td> <td align=\"center\">not found</td>   </tr>\n")
        summary.write("<tr><th align=\"left\">Cons</th><td align=\"center\">mature miRNA conservation level</td>  <td align=\"center\">miRNA precursor conservation level</td> <td align=\"center\">not conserved</td align=\"center\"> <td align=\"center\">conservation score of 0</td>   </tr>\n")
        summary.write("<tr><th align=\"left\">Shad</th><td align=\"center\">mature miRNA shadowing level</td>  <td align=\"center\">miRNA precursor shadowing level</td> <td align=\"center\">not conserved</td align=\"center\"> <td align=\"center\">shadowing score of 0</td>   </tr>\n")
        summary.write("<tr><th align=\"left\">miRB</th><td align=\"center\">overlaps with a miRBase miRNA</td>  <td align=\"center\"></td> <td align=\"center\"></td> <td align=\"center\">no overlap</td>   </tr>\n")
        summary.write("<tr><th align=\"left\">Clust</th><td align=\"center\">clusters with >5 miRNAs</td>  <td align=\"center\">clusters with 1 to 5 miRNAs</td> <td align=\"center\">clusters with 1 miRNA</td> <td align=\"center\">no cluster</td>   </tr>\n")
        summary.write("<tr><th align=\"left\">rFam</th><td align=\"center\">overlaps with an RFam ncRNA</td>  <td align=\"center\"></td> <td align=\"center\"></td> <td align=\"center\">no overlap</td>   </tr>\n")
        summary.write("</table><br /><br /><br />\n")
        

        summary.write("<b>Result Summary: </b><br /><br />\n")
        summary.write("<table border=\"0\">\n")
        summary.write("<tr><th width=80 align=\"left\">Name</th><th width=80>Pred</th><th width=80>Cons</th><th width=80>Shad</th><th width=80>miRB</th><th width=80>Clust</th><th width=80>rFam</th></tr>\n")
        
        text_res=open(res_no+"/res_text.txt","w")
        for x in sorted_keys:
            kary=[]
            #inq_len=[]
            ref=[]
            transcripts=[]
            transcripts_html=[]
            heatmap1=[]
            heatmap2=[]
            name=[]
            hist1=[]
            hist2=[]
            leng1=[]
            leng2=[]
            all_neigh=[]
            all_neigh_pre=[]
            amount_neigh=[]
            all_pred=[]
            all_predname=[]
            all_nc=[]
            chr_display=[]
            all_alig=[]
            all_tfb=[]
            all_tfb_tot=[]
            disjo=[]
            all_mir_hit=0
            all_rfam_hit=0
            #all_cons=[]
            #all_shad=[]
        
        
            cmd="mkdir "+"\""+res_no+"/"+str(x[1])+"\""
            sta,out=commands.getstatusoutput(cmd)

            #summary.write("<tr><td align=\"left\"><a href=\"http://mimirna.centenary.org.au/cgi-bin/mireval/diagram.py?job_id="+res_no+"&inq_id="+str(x[1])+"\" target=\"_blank\">Seq_"+str(x[1])+"</a></td>\n")
            summary.write("<tr><td align=\"left\"><a href=\""+str(x[1])+"/index.html"+"\" target=\"_blank\">Seq_"+str(x[1])+"</a></td>\n")
            
            ini=0
            for y in dblast[x]:
                if y["chr"]=="":
                    each_seq=[]
                    seq_tmp_file=open(res_no+"/"+seq_file,"rU")
                    for fa_record in SeqIO.parse(seq_tmp_file, "fasta"):
                        each_seq.append(str(fa_record.seq))
                    seq_tmp_file.close()
                    
                    htm=open(res_no+"/"+str(x[1])+"/index.html","w")
                    htm.write("<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"><head><meta http-equiv=\"content-type\" content=\"application/xhtml+xml; charset=utf-8\" /><link rel=\"shortcut icon\" ><title>Result of "+x[0]+"</title></head>"+"<body><h2 align=\"center\">Result of "+x[0]+"</h2>"+"<b>Sequence No.:</b><br />"+str(x[1])+"<br /><br /><br />\n")
                    htm.write("<b>Your inquiry sequence:</b><br />\n")
                    htm.write(each_seq[x[1]-1]+"<br />\n")
                    htm.write("<b>Not Mappable</b><br />\n")
                    htm.close()
                    text_res.write(x[0]+" start\n")
                    text_res.write("Your inquiry sequence:\n")
                    text_res.write(each_seq[x[1]-1]+"\n")
                    text_res.write("Not mappable\n")
                    text_res.write(x[0]+" end\n\n\n")
                        
                    break
                else:
                    ini=1
                    if (y["chr"] in chr_display)==False:
                        chr_display.append(y["chr"])
                    kary.append("chr"+"\t"+"-"+"\t"+y["chr"]+"\t"+y["chr"]+"\t"+str(y["start_outer"])+"\t"+str(y["end_outer"])+"\t"+"grey"+"\t"+y["strand"]+"\n")
                    #inq_len.append(y["end"]-y["start"]+1)
                    #ref.append(y["chr"]+"\t"+str(y["start"])+"\t"+str(y["end"])+"\t"+"color=vdyellow"+"\t"+y["strand"]+"\n")
                    ref.append(y["chr"]+"\t"+str(y["start"])+"\t"+str(y["end"])+"\t"+"100\tid="+y["strand"]+"_Your_inquiry"+"\n")
                    transcripts=transcripts+y["trans"]
                    transcripts_html=transcripts_html+y["trans_html"]
                    hist1.append(y["plot1"])
                    hist2.append(y["plot2"])

                    #a=y["nearby"]+y["tfb"]+y["pred"]+y["nc"]+y["trans"]
                    #a1=y["nearby"]
                    #aa1=sort_list(a1)
                    #disjo1=disjoint(aa1,res=[])

                    #heatmap1.append(disjo1)
                    #leng1.append(len(disjo1))

                    
                    all_neigh= all_neigh+y["nearby"]
                    all_neigh_pre= all_neigh_pre+y["nearby_pre"]
                    if y["mir_hit"]==1:
                        amount_neigh.append(len(y["nearby"])-2)
                    else:
                        amount_neigh.append(len(y["nearby"]))
                    all_pred=all_pred+y["frag"]
                    all_predname=all_predname+y["pred"]
                    all_nc=all_nc+y["nc"]
                    all_alig=all_alig+y["alig"]
                    all_tfb=all_tfb+y["tfb"]
                    all_tfb_tot=all_tfb_tot+y["tfb_tot"]
                    all_mir_hit=all_mir_hit+y["mir_hit"]
                    all_rfam_hit=all_rfam_hit+y["rfam_hit"]
        
        
            if ini==1:
                text_res.write(x[0]+" start\n")       
                htm=open(res_no+"/"+str(x[1])+"/index.html","w")
                htm.write("<!DOCTYPE HTML>\n")
                htm.write("<html><head><meta http-equiv=Content-Type content='text/html;charset=utf-8'><link rel=\"shortcut icon\" ><title>Result of "+x[0]+"</title></head>\n")
                htm.write("<body><h2 align=\"center\">Result of "+x[0]+"</h2><br />\n")

                htm.write("<br /><br /><b>mir-like hairpin prediction:</b><br />\n")
                text_res.write("mir-like hairpin prediction:\n")
                if all_pred!=[]:
                    summary.write("<td bgcolor=\"#B40404\"></td>\n")
                    m=0
                    v_no=1
                    cons_val=[]
                    shad_val=[]
                    f=open(res_no+"/"+str(x[1])+"/pred.txt","w")
                    #fi=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/pred_name.txt","w")
                    for pred_info in all_pred:
                        if m%3==0:
                            t0=pred_info.split(";")
                            htm.write("<a name='"+t0[0]+"'>"+">"+t0[0]+":"+t0[1][:-1]+"</a><br />\n")
                            text_res.write(">"+t0[0]+":"+t0[1][:-1]+"\n")
                            t1=t0[1].split(":")[0]+"\t"+t0[1].split(":")[1].split("-")[0]+"\t"+t0[1].split(":")[1].split("-")[1]+"\tid="+t0[1][:-1].split(":")[-1]+"_"+t0[0]+"\n"
                            #t2=t0[1].split(":")[0]+"\t"+t0[1].split(":")[1].split("-")[0]+"\t"+t0[1].split(":")[1].split("-")[1]+"\t"+t0[0]+"\n"
                            f.write(t1)
                            #fi.write(t2)
                            if method_avbl[0]==1:
                                pred_q_chr=t0[1].split(":")[0]
                                pred_q_start=int(t0[1].split(":")[1].split("-")[0])
                                pred_q_end=int(t0[1].split(":")[1].split("-")[1])
                                pred_q_cons=conserve_score(root,res_no,pred_q_chr,pred_q_start,pred_q_end,cons_dir)
                                #consv=score_zf(pred_q_cons)/(pred_q_end-pred_q_start+1)
                                consv=score_max(pred_q_cons)
                            else:
                                consv="NA"
                            cons_val.append(consv)
                            if method_avbl[1]==1:
                                pred_q_chr=t0[1].split(":")[0]
                                pred_q_start=int(t0[1].split(":")[1].split("-")[0])
                                pred_q_end=int(t0[1].split(":")[1].split("-")[1])
                                pred_q_shadow=conserve_score(root,res_no,pred_q_chr,pred_q_start,pred_q_end,shad_dir)
                                #shadv=score_zf(pred_q_shadow)/(pred_q_end-pred_q_start+1)
                                shadv=score_max(pred_q_shadow)
                            else:
                                shadv="NA"
                            shad_val.append(shadv)
                        if m%3==1:
                            pred_seq=pred_info[:-1]
                            htm.write(pred_info[:-1]+"<br />\n")
                            text_res.write(pred_seq+"\n")
                        if m%3==2:
                            pred_struct=pred_info[:-1].split(" ")[0]
                            htm.write(pred_info[:-1]+"<br />\n")
                            text_res.write(pred_info[:-1]+"\n")
                            cmd="/usr/bin/java -Djava.awt.headless=true -cp "+root+"/mireval/bin/varna/VARNAv3-9.jar fr.orsay.lri.varna.applications.VARNAcmd -sequenceDBN '"+pred_seq+"' -structureDBN '"+pred_struct+"' -o "+res_no+"/"+str(x[1])+"/varna"+str(v_no)+".png"
                            sta,out=commands.getstatusoutput(cmd)
                            #htm.write("<img style='border:none;' src='http://mimirna.centenary.org.au/mireval/res/"+res_no+"/"+str(x[1])+"/varna"+str(v_no)+".png'></img><br />\n")
                            htm.write("<img style='border:none;' src='varna"+str(v_no)+".png'></img><br />\n")
                            v_no+=1
                        m+=1
                    f.close()

                else:
                    cons_val=[]
                    shad_val=[]
                    htm.write("None<br />\n")
                    text_res.write("None\n")
                    summary.write("<td></td>\n")
                    if method_avbl[0]==1:
                        plot_no=0
                        for aplot in hist1:
                            consv=score_max(aplot)
                            cons_val.append(consv)
                        plot_no+=1
                    else:
                        cons_val.append("NA")
                    if method_avbl[1]==1:
                        plot_no=0
                        for aplot in hist2:
                            shadv=score_max(aplot)
                            shad_val.append(shadv)
                        plot_no+=1
                    else:
                        shad_val.append("NA")

                if max(cons_val)>=method_avbl[5] and max(cons_val)!="NA":
                    summary.write("<td bgcolor=\"#B40404\"></td>\n")
                #if max(cons_val)>=method_avbl[5] and max(cons_val)<method_avbl[6]:
                #    summary.write("<td bgcolor=\"#DF0101\"></td>\n")
                if max(cons_val)>=method_avbl[4] and max(cons_val)<method_avbl[5]:
                    summary.write("<td bgcolor=\"#FA5858\"></td>\n")
                if max(cons_val)<method_avbl[4] and max(cons_val)>0:
                    summary.write("<td bgcolor=\"#F5A9A9\"></td>\n")
                if max(cons_val)==0:
                    summary.write("<td></td>\n")
                if max(cons_val)=="NA":
                    summary.write("<td align=\"center\">NA</td>\n")
                if max(shad_val)>=method_avbl[7] and max(shad_val)!="NA":
                    summary.write("<td bgcolor=\"#B40404\"></td>\n")
                #if max(shad_val)>=method_avbl[8] and max(shad_val)<method_avbl[9]:
                #    summary.write("<td bgcolor=\"#DF0101\"></td>\n")
                if max(shad_val)>=method_avbl[6] and max(shad_val)<method_avbl[7]:
                    summary.write("<td bgcolor=\"#FA5858\"></td>\n")
                if max(shad_val)<method_avbl[6] and max(shad_val)>0:
                    summary.write("<td bgcolor=\"#F5A9A9\"></td>\n")
                if max(shad_val)==0:
                    summary.write("<td></td>\n")
                if max(shad_val)=="NA":
                    summary.write("<td align=\"center\">NA</td>")
                
                

                htm.write("<br /><br /><b>Result Visualization:</b>\n")
                htm.write("<br /><br />\n")
                #htm.write("<div style=\"position:relative\" left=0 top=0>")
                

                htm.write("\nTo show this graph, please run <b>mireval2-diagram -t "+res_no+" -n "+str(x[1])+"</b> , and then refresh this page\n")
                blank_line=3*"<br />\n"
                htm.write(blank_line)
                #htm.write("<script type=\"text/javascript\">\n$(\'.circosimg\').imagesLoaded(function( $images, $proper, $broken ) {$(\'#circosloading\').hide();});\n</script>\n")

                
                #if base_no>2:
                htm.write("<b>Sequence No.:</b><br />"+str(x[1])+"<br /><br /><br />\n")
                htm.write("<a name='Your_inquiry'>"+"<b>Your inquiry sequence BLAST: </b></a><br />\n")
                text_res.write("Inquiry ID: "+res_no+"\n")
                text_res.write("Inquiry:\n")
                for blast_info in all_alig:
                    t0=blast_info.split("\n")
                    #htm.write(t0[0]+"<br />"+t0[1]+"<br />"+t0[2]+"<br /><font face=\"Courier\">"+t0[3]+"<br />"+t0[4]+"<br />"+t0[5]+"</font><br /><br />\n")
                    htm.write("<b>Query Region:</b> "+t0[0][6:]+"<br /><b>Target:</b> "+t0[1]+"<br /><br />\n")
                    text_res.write(blast_info)
                
                htm.write("<br /><br /><b>Which transcripts overlap your inquiry sequence? (<a href='http://genome.ucsc.edu/cgi-bin/hgGateway'>UCSC Genome Browser</a>)</b><br />\n")
                text_res.write("Transcripts:\n")
                
                if transcripts_html != []:
                    for trans_info in transcripts_html:
                        name_acc=trans_info.split(";")[0]
                        t0=trans_info.split(";")[1][:-1]
                        htm.write("<a name='"+name_acc+"'>"+"<b>"+name_acc+"</b></a>:"+t0+"<br />\n")
                        text_res.write(name_acc+"\t"+t0+"\n")
                        t1=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\tid="+t0.split(":")[-1]+"_"+name_acc+"\n"
                        t2=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\t"+name_acc+"\n"
                else:
                    htm.write("None<br />\n")
                    text_res.write("None\n")

                if transcripts != []:
                    f=open(res_no+"/"+str(x[1])+"/transcript.txt","w")
                    for trans_info in transcripts:
                        name_acc=trans_info.split(";")[0]
                        t0=trans_info.split(";")[1][:-1]
                        t1=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\tid="+t0.split(":")[-1]+"_"+name_acc+"\n"
                        f.write(t1)
                    f.close()

        
                htm.write("<br /><br /><b>Which transcription factor binding sites potentially regulate your inquiry sequence?</b><br />\n")
                text_res.write("Tansciption binding sites:\n")
        
                if all_tfb!=[]:
                    f=open(res_no+"/"+str(x[1])+"/tfb.txt","w")
                    #fi=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/tfb_name.txt","w")
                    for tfb_info in all_tfb:
                        name=tfb_info.split(";")[0][4:]
                        t0=tfb_info.split(";")[1][:-1]
                        t1=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\t100\tcolor=green,id="+t0.split(":")[-1]+"_"+name+"\n"
                        #t2=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\t"+name.split("-")[1]+"\n"
                        f.write(t1)
                        #fi.write(t2)
                    f.close()
                    #fi.close()

                
                if all_tfb_tot!=[]:
                    for tfb_info in all_tfb_tot:
                        name=tfb_info.split(";")[0][4:]
                        t0=tfb_info.split(";")[1][:-1]
                        htm.write("<a name='"+name+"'>"+"<b>"+name+"</b></a>:"+t0+"<br />\n")
                        text_res.write(name+"\t"+t0+"\n")
                else:
                    htm.write("None<br />\n")
                    text_res.write("None\n")

        
                htm.write("<br /><br /><b>Which miRs are nearby your inquiry sequence? (<a href='http://www.mirbase.org/'>miRBase</a>)</b><br />\n")
                text_res.write("miRNA cluster from miRBase:\n")
                
                if method_avbl[2]==1:
                    if all_mir_hit>0:
                        summary.write("<td bgcolor=\"#B40404\"></td>\n")
                    else:
                        summary.write("<td></td>\n")
                else:
                    summary.write("<td align=\"center\">NA</td>\n")
                
                if all_neigh!=[]:
                    f=open(res_no+"/"+str(x[1])+"/mir.txt","w")
                    #fi=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/mir_name.txt","w")
                    for mir_info in all_neigh:
                        name_acc=mir_info.split(";")[0]
                        name=name_acc.split("\t")[0]
                        acc=name_acc.split("\t")[1]
                        t0=mir_info.split(";")[1][:-1]
                        htm.write("<a href=http://www.mirbase.org/cgi-bin/mirna_entry.pl?acc="+acc+" target=\"_blank\">"+acc+"</a>:"+"<a name='"+name+"'>"+"<b>"+name+"</b></a>:"+t0+"<br />\n")
                        text_res.write(acc+"\t"+name+"\t"+t0+"\n")
                        t1=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\tid="+t0.split(":")[-1]+"_"+name+"\n"
                        #t2=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\t"+name+"\n"
                        f.write(t1)
                        #fi.write(t2)
                    f.close()
                    #fi.close()
                    if max(amount_neigh)>5:
                        summary.write("<td bgcolor=\"#B40404\"></td>\n")
                    #if max(amount_neigh)>3 and max(amount_neigh)<=5:
                    #    summary.write("<td bgcolor=\"#DF0101\"></td>\n")
                    if max(amount_neigh)>=1 and max(amount_neigh)<=5:
                        summary.write("<td bgcolor=\"#FA5858\"></td>\n")
                    if max(amount_neigh)<1:
                        summary.write("<td bgcolor=\"#F5A9A9\"></td>\n")
                else:
                    if method_avbl[2]==0:
                        htm.write("NA<br />\n")
                        text_res.write("NA\n")
                        summary.write("<td align=\"center\">NA</td>\n")
                    else:
                        htm.write("None<br />\n")
                        text_res.write("None\n")
                        summary.write("<td></td>\n")
                
                #if all_neigh_pre!=[]:
                #    f=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/mir_name.txt","w")
                #    f.writelines(all_neigh_pre)
                #    f.close()
        
                htm.write("<br /><br /><b>Does your inquiry sequence hit a non-coding RNA? (<a href='http://rfam.sanger.ac.uk/'>Rfam</a>):</b><br />\n")
                text_res.write("Non-coding RNA clustering from Rfam:\n")
    
                if method_avbl[3]==1:
                    if all_rfam_hit>0:
                        summary.write("<td bgcolor=\"#B40404\"></td>\n")
                    else:
                        summary.write("<td></td>\n")
                else:
                    summary.write("<td align=\"center\">NA</td>\n")

                summary.write("</tr>\n")
    
                if all_nc!=[]:
                    f=open(res_no+"/"+str(x[1])+"/nc.txt","w")
                    #fi=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/nc_name.txt","w")
                    for nc_info in all_nc:
                        name_acc=nc_info.split(";")[0]
                        name=name_acc.split("\t")[0]
                        acc=name_acc.split("\t")[1]
                        t0=nc_info.split(";")[1][:-1]
                        htm.write("<a href=http://rfam.sanger.ac.uk/family/"+acc+" target=\"_blank\">"+acc+"</a>:"+"<a name='"+name+"'>"+"<b>"+name+"</b></a>:"+t0+"<br />\n")
                        text_res.write(acc+"\t"+name+"\t"+t0+"\n")
                        t1=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\tid="+t0.split(":")[-1]+"_"+name+"\n"
                        t2=t0.split(":")[0]+"\t"+t0.split(":")[1].split("-")[0]+"\t"+t0.split(":")[1].split("-")[1]+"\t"+name+"\n"
                        f.write(t1)
                        #fi.write(t2)
                    f.close()
                    #fi.close()
                else:
                    if method_avbl[3]==0:
                        htm.write("NA<br />\n")
                        text_res.write("NA\n")
                    else:
                        htm.write("None<br />\n")
                        text_res.write("None\n")
        
                
                
                # /home/shared/mireval/bigWigToBedGraph score.bw -chrom=chrX -start=60540 -end=60549 score.txt
                # conserve_score(root_name,result_no,chromosome,start_cor,end_cor,species,method)

                #htm.write("<br /><br /><b>Phylogenic Conservation Score:</b><br />")
                text_res.write("Phylogenic Conservation Score:\n")
        
                
                hist1_inone=[]
                for aplot in hist1:
                    hist1_inone=hist1_inone+aplot
                if hist1_inone!=[]:
                    for con_info in hist1_inone:
                        t0=con_info.split("\t")
                        #htm.write(t0[0]+":"+t0[1]+"-"+t0[2]+":"+t0[3][:-1]+"<br />")
                        text_res.write(t0[0]+":"+t0[1]+"-"+t0[2]+":"+t0[3][:-1]+"\n")
                else:
                    #htm.write("NA<br />")
                    text_res.write("NA\n")
                #htm.write("<br /><br /><b>Phylogenic Shadowing Score:</b><br />")
                text_res.write("Phylogenic Shadowing Score:\n")


                hist2_inone=[]
                for aplot in hist2:
                    hist2_inone=hist2_inone+aplot
                if hist2!=[]:
                    for shadow_info in hist2_inone:
                        t0=shadow_info.split("\t")
                        #htm.write(t0[0]+":"+t0[1]+"-"+t0[2]+":"+t0[3][:-1]+"<br />")
                        text_res.write(t0[0]+":"+t0[1]+"-"+t0[2]+":"+t0[3][:-1]+"\n")
                else:
                    #htm.write("NA<br />")
                    text_res.write("NA\n")
                


                htm.write("</body></html>\n")
                htm.close()
        
        #
                f=open(res_no+"/"+str(x[1])+"/karyo.txt","w")
                f.writelines(kary)
                f.close()
                f=open(res_no+"/"+str(x[1])+"/ref.txt","w")
                f.writelines(ref)
                f.close()
                f0=open(res_no+"/"+str(x[1])+"/hist_label1.txt","w")
                f1=open(res_no+"/"+str(x[1])+"/hist_label2.txt","w")
                f2=open(res_no+"/"+str(x[1])+"/nc_label.txt","w")
                f3=open(res_no+"/"+str(x[1])+"/mir_label.txt","w")
                f4=open(res_no+"/"+str(x[1])+"/pred_label.txt","w")
                f5=open(res_no+"/"+str(x[1])+"/transcript_label.txt","w")
                f6=open(res_no+"/"+str(x[1])+"/tfb_label.txt","w")
                f7=open(res_no+"/"+str(x[1])+"/ref_label.txt","w")
                #f8=open(root+"/mireval/html/res/"+res_no+"/"+str(x[1])+"/label_bg.txt","w")
                for refi in ref:
                    f0.write("\t".join(refi.split("\t")[:3]+["[?]Conservation"])+"\n")
                    f1.writelines("\t".join(refi.split("\t")[:3]+["[?]Shadowing"])+"\n")
                    f2.writelines("\t".join(refi.split("\t")[:3]+["[?]ncRNAs"])+"\n")
                    f3.writelines("\t".join(refi.split("\t")[:3]+["[?]miRNAs"])+"\n")
                    f4.writelines("\t".join(refi.split("\t")[:3]+["[?]Hairpins"])+"\n")
                    f5.writelines("\t".join(refi.split("\t")[:3]+["[?]Transcripts"])+"\n")
                    f6.writelines("\t".join(refi.split("\t")[:3]+["[?]TF_Sites"])+"\n")
                    f7.writelines("\t".join(refi.split("\t")[:3]+["Your_Seq"])+"\n")
                    #f8.writelines("\t".join(refi.split("\t")[:3]+["color=vvlblue"])+"\n")
                f0.close()
                f1.close()
                f2.close()
                f3.close()
                f4.close()
                f5.close()
                f6.close()
                f7.close()
                #f8.close()

                f=open(res_no+"/"+str(x[1])+"/histo1.txt","w")
                f.writelines(hist1_inone)
                f.close()
                f=open(res_no+"/"+str(x[1])+"/histo2.txt","w")
                f.writelines(hist2_inone)
                f.close()

                circos_create=cir(root, res_no, str(x[1]),chr_display, method_avbl[4:])
                text_res.write(x[0]+" end\n\n\n")
        
        text_res.close()
        
        summary.write("</table>\n")
    
    #exits=1

    
    if blast_true==1:
        summary.write("</body></html>\n")
        summary.close()
        #if base_no>2:
        #    redirect(main_page+"/res/"+res_no+"/")
        #if base_no==2:
        #    redirect("http://mimirna.centenary.org.au/cgi-bin/mireval/diagram.py?job_id="+res_no+"&inq_id=1")


# Other species
else:
    cmd="mkdir "+res_no
    sta,out=commands.getstatusoutput(cmd)
    
    seq_file=seq_file_path.split("/")[-1]

    blast_true=1
    seq_check=[]

    f=open(seq_file_path,"rU")
    for check_record in SeqIO.parse(f,"fasta"):
        seq_check.append(check_record)
    f.close()
    #print seq_check

    if seq_check==[]:
        blast_true=0
        #cmd="rm "+seq_file_path
        #sta,out=commands.getstatusoutput(cmd)
    else:
        if reverse_search=="no":
            cmd="cp "+seq_file_path+" "+res_no+"/"
            sta,out=commands.getstatusoutput(cmd)
        #    cmd="rm "+seq_file_path
        #    sta,out=commands.getstatusoutput(cmd)
        else:
            d=[]
            for x in seq_check:
                up_seq=(x.seq).reverse_complement()
                up_id=(x.id)+"_complement"
                up_name=(x.name)+"_complement"
                up_des=(x.description)+"_complement"
                d.append(SeqRecord(up_seq,up_id,'',''))
            f=open(res_no+"/"+seq_file,"w")
            SeqIO.write(d, f, "fasta")
            f.close()
        #    cmd="rm "+seq_file_path
        #    sta,out=commands.getstatusoutput(cmd)



    if blast_true==0:
        print "BLAST Error: make sure your input file is in FASTA format and your sequences DO NOT contain any other letters A,T,C,G,U,N."

    else:
        cmd="blastall -p blastn -d "+root+"/mireval/genomes/mirbase/blastdb -i "+res_no+"/"+seq_file+" -m 7 -o "+res_no+"/"+"temp.txt"
        #print cmd
        sta,out=commands.getstatusoutput(cmd)
    
        if out!="":
            blast_true=0
            print "BLAST Error: make sure your input file is in FASTA format and your sequences DO NOT contain any other letters A,T,C,G,U,N."
    
    if blast_true==1:
        dblast={}
        base_no=1
        dfrag=[]
        f=open(res_no+"/"+seq_file,"rU")
        for x in SeqIO.parse(f,"fasta"):
            dblast[(x.id, base_no)]=[{"id":str(base_no),"frag":[],"pred":[],"seq":str(x.seq),"known":[]}]
            dfrag=dfrag+disect(root,str(base_no),"chrN","chrN",1,len(str(x.seq)),"+",str(x.seq),85)
            base_no+=1
        
        f.close()

        # find hairpin

        dn=["AA","AU","AC","AG","UA","UU","UC","UG","CA","CU","CC","CG","GA","GU","GC","GG","--","-A","-U","-G","-C","A-","U-","G-","C-","NA","NN","NG","NC","NU","N-","-N","UN","GN","CN","AN"]
        asb=["(((",".((","(.(","((.","..(",".(.","(..","..."]
        nucl=['A','U','C','G']
        fea=[]
        for a in nucl:
            for b in asb:
                fea.append(a+b)
    
        f=open(res_no+"/testseq.txt","w")
        f.writelines(dfrag)
        f.close()
    
        cmd="less "+res_no+"/testseq.txt|/usr/local/bin/RNAfold --noPS > "+res_no+"/testfold.txt"
        sta,out=commands.getstatusoutput(cmd)
        
    
        f = open(res_no+"/testfold.txt","r")
        data=f.readlines()
        f.close()
    
        f = open(res_no+"/test_features.txt",'w')
        n=0
        while n<len(data):
            seq4svm =data[n+1][:-1].upper()
            fold=data[n+2].split(" ")[0]
            mfe=data[n+2].split(" ")[-1].split(")")[0].split("(")[-1]
            head_mark="0"
            temp_svm=features(seq4svm,fold,mfe,dn,fea,head_mark)
            f.write(temp_svm)
            n+=3
        f.close()
    
        cmd=root+"/mireval/bin/svm_light/bin/svm_classify "+res_no+"/test_features.txt "+root+"/mireval/ref/svm/model.txt "+res_no+"/res_svm.txt"
        print cmd
        sta,out=commands.getstatusoutput(cmd)
        f=open(res_no+"/res_svm.txt","r")
        svm_res=f.readlines()
        f.close()
    
        i=0
        pred_no=1
        while i< len(data):
            if float(svm_res[int(i/3)][:-1])>0:
                for y in dblast:
                    for z in dblast[y]:
                        if z["id"]==data[i].split(";")[0][1:]:
                            pred_name="pred"+str(pred_no)+";"+data[i].split(";")[1][:-1]
                            pred_no+=1
                            z["pred"].append(pred_name+"\n")
                            z["frag"].append(pred_name+"\n")
                            z["frag"].append(data[i+1])
                            z["frag"].append(data[i+2])
                            break
        
            i+=3

        # Blast against known miRNA

        cmd="blastall -p blastn -d "+root+"/mireval/genomes/mirbase/blastdb -i "+res_no+"/testseq.txt"+" -m 7 -o "+res_no+"/"+"temp.txt"
        sta,out=commands.getstatusoutput(cmd)
        blast_records = NCBIXML.parse(open(res_no+"/temp.txt"))
        
        
        for x in blast_records:
            query_id=str((x.query).split(";")[0])
            query_area=str((x.query).split(";")[1].split(":")[1])
            query_start=int(query_area.split("-")[0])
            for y in dblast:
                for z in dblast[y]:
                    if z["id"]==query_id:
                        for ali in x.alignments:
                            hsp=ali.hsps[0]
                            ident=int(hsp.identities)
                            align_len=int(hsp.align_length)
                            hit_name=str(ali.title)
                            acc=hit_name.split(" ")[1]
                            name=" ".join(hit_name.split(" ")[:1]+hit_name.split(" ")[2:])
                            gaps=int(hsp.gaps)
                            if (ident+2>=ali.length or ident+2>=x.query_length) and hsp.frame==(1,1):
                                align_start=query_start+int(hsp.query_start)-1
                                align_end=query_start+int(hsp.query_end)-1
                                z["known"].append("Query "+str(align_start)+"-"+str(align_end)+"\nTarget "+name+"\t"+acc+"\n"+str(hsp.query)+"\n"+str(hsp.match)+"\n"+str(hsp.sbjct)+"\n")

        # output

        sorted_keys=sorted(dblast.keys(), key=itemgetter(1, 0))
     
        summary=open(res_no+"/index.html","w")
        #summary.write("<html><head></head><body><table border=1 align=\"center\"><tr valign=\"middle\"><h2 align=\"center\">Inquiry ID: "+res_no+"</h2>\n")
        summary.write("<!DOCTYPE html>\n")
        summary.write("<html><head><meta http-equiv=Content-Type content='text/html;charset=utf-8'><link rel=\"shortcut icon\" ><title>Result Summary</title></head><h2 align=\"center\">Inquiry ID: "+res_no+"</h2>\n")
        summary.write("<b>Which sequence should I look at first?</b><br /><br />\n")
        summary.write("<table border=\"0\">\n")
        summary.write("<tr height=20><th width=80 align=\"left\"></th><td width=275 bgcolor=\"#B40404\"></td><td width=275></td></tr>\n")
        summary.write("<tr><th align=\"left\">Pred</th><td align=\"center\">found hairpins</td><td align=\"center\">not found</td> </tr>\n")
        summary.write("<tr><th align=\"left\">miRB</th><td align=\"center\">aligns to a miRBase miRNA</td><td align=\"center\">not align to any miRBase miRNA</td> </tr>\n")
        summary.write("</table><br /><br /><br />\n")


        
        summary.write("<b>Result Summary: </b><br /><br />\n")
        summary.write("<table border=\"0\">\n")
        summary.write("<tr><th width=80 align=\"left\">Name</th><th width=80>Pred</th><th width=80>miRB</th></tr>\n")
        
        text_res=open(res_no+"/res_text.txt","w")
    
        for x in sorted_keys:
            #name=[]
            #all_pred=[]
            #all_predname=[]

            cmd="mkdir "+"\""+res_no+"/"+str(x[1])+"\""
            sta,out=commands.getstatusoutput(cmd)

            #summary.write("<tr><td align=\"left\"><a href=\"http://mimirna.centenary.org.au/mireval/res/"+res_no+"/"+str(x[1])+"/index.html"+"\" target=\"_blank\">Seq_"+str(x[1])+"</a></td>\n")
            summary.write("<tr><td align=\"left\"><a href=\""+str(x[1])+"/index.html"+"\" target=\"_blank\">Seq_"+str(x[1])+"</a></td>\n")

            for y in dblast[x]:
                text_res.write(x[0]+" start\n")       
                htm=open(res_no+"/"+str(x[1])+"/index.html","w")
                htm.write("<!DOCTYPE HTML>\n")
                htm.write("<html><head><meta http-equiv=Content-Type content='text/html;charset=utf-8'><link rel=\"shortcut icon\" ><title>Result of "+x[0]+"</title><script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script><script src=\"http://mimirna.centenary.org.au/mireval/jquery.imagesloaded.min.js\"></script></head>\n")
                htm.write("<body><h2 align=\"center\">Result of "+x[0]+"</h2><br />\n")

                #htm.write("<br /><br /><b>Your inquiry sequence:</b><br />\n")
                #htm.write(y["seq"]+"<br />\n")
                htm.write("<br /><br /><b>mir-like hairpin predictions:</b><br />\n")
                text_res.write("Your inquiry sequence:\n")
                text_res.write(y["seq"]+"\n")
                text_res.write("mir-like hairpin predictions:\n")
                if y["frag"]!=[]:
                    summary.write("<td bgcolor=\"#B40404\"></td>\n")
                    m=0
                    v_no=1
                    for pred_info in y["frag"]:
                        if m%3==0:
                            t0=pred_info.split(";")
                            htm.write(">"+t0[0]+":"+t0[1][:-1].split(":")[1]+"<br />\n")
                            text_res.write(">"+t0[0]+":"+t0[1][:-1].split(":")[1]+"\n")

                        if m%3==1:
                            pred_seq=pred_info[:-1]
                            htm.write(pred_info[:-1]+"<br />\n")
                            text_res.write(pred_seq+"\n")
                        if m%3==2:
                            pred_struct=pred_info[:-1].split(" ")[0]
                            htm.write(pred_info[:-1]+"<br />\n")
                            text_res.write(pred_info[:-1]+"\n")
                            cmd="/usr/bin/java -Djava.awt.headless=true -cp "+root+"/mireval/bin/varna/VARNAv3-9.jar fr.orsay.lri.varna.applications.VARNAcmd -sequenceDBN '"+pred_seq+"' -structureDBN '"+pred_struct+"' -o "+res_no+"/"+str(x[1])+"/varna"+str(v_no)+".png"
                            sta,out=commands.getstatusoutput(cmd)
                            htm.write("<img style='border:none;' src='varna"+str(v_no)+".png'></img><br />\n")
                            v_no+=1
                            
                        m+=1
                else:
                    htm.write("None<br />\n")
                    text_res.write("None\n")
                    summary.write("<td></td>\n")
                

                htm.write("<br /><br /><b>Aligments with miRBase miRNAs:</b><br />\n")
                text_res.write("Aligments with miRBase miRNAs:\n")
                if y["known"]!=[]:
                    summary.write("<td bgcolor=\"#B40404\"></td></tr>\n")
                    for aligns in y["known"]:
                        t0=aligns.split("\n")
                        htm.write("<b>Query:</b> "+t0[0][6:]+"<br /><b>Target:</b> <a href=http://www.mirbase.org/cgi-bin/mirna_entry.pl?acc="+t0[1][7:].split("\t")[1]+" target=\"_blank\">"+t0[1][7:].split("\t")[0]+"</a><br /><font face=\"Courier\">"+t0[2]+"<br />"+t0[3]+"<br />"+t0[4]+"</font><br /><br />\n")
                        text_res.write(aligns)
                else:
                    htm.write("None<br />\n")
                    text_res.write("None\n")
                    summary.write("<td></td></tr>\n")
                text_res.write(x[0]+" end\n\n\n")
    
        htm.write("</body></html>\n")
        htm.close()
        text_res.close()
        summary.write("</table>\n")
        summary.write("</body></html>\n")
        summary.close()

    #exits=1
    #if blast_true==1:
        #if base_no>2:
        #    redirect(main_page+"/res/"+res_no+"/")
        #if base_no==2:
        #    redirect("http://mimirna.centenary.org.au/mireval/res/"+res_no+"/1/index.html")
